---
layout: post
title: 백엔드 면접을 위한 IT 용어 정리
date: 2024-06-01
Author: Geon Son
categories: IT
tags: [IT]
comments: true
toc: true
---


>[네트워크 & 운영체제 용어 참고](https://geondev.github.io/it-word-list-network/)  
>[참고](https://github.com/ksundong/backend-interview-question?tab=readme-ov-file)

이직을 준비하면서 이론을 너무 까먹어서 정리하려고 한다.  <br>


# 용어정리 – 데이터 베이스
* **OLTP(OnLine Transaction Processing)**: 네트워크상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 방식을 말한다. 주로 신용카드 조회 업무나 자동 현금 지급 등 금융 전산 관련 부문에서 많이 발생하기 때문에 ‘온라인 거래처리’라고도 한다. (효율적 처리 중심)

* **OLAP(OnLine Analytical Processing)**: 사용자가 다양한 각도에서 직접 대화식으로 정보를 분석하는 과정을 말한다. OLAP 시스템은 단독으로 존재하는 정보 시스템이 아니며, 데이터 웨어하우스나 데이터 마트와 같은 시스템과 상호 연관된다. (데이터 분석 중심)

* **트랜잭션 격리수준(Isolation Level)**: 동시에 여러 트랜잭션이 실행될 때, 트랜잭션 끼리 서로 얼마나 고립 되어 있는지를 확인하는 것, 특정 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 조회할 수 있는지 없는지 판단한다. 격리수준이 내려갈수록 성능이 좋아지지만 오류가 발생할 가능성이 커진다.

  * **READ UNCOMMITTED**: 어떤 트랙잭션의 변경내용이 COMMIT이나 ROLLBACK에 상관없이 모두 노출된다. 데이터의 정합성 문제로 RDBMS 표준에서는 인정하지 않는다.

  * **READ COMMITTED**: 어떤 트랜잭션의 변경내용이 COMMIT되어야만 다른 트랜잭션에서 조회할 수 있다. NON-REPETABLE READ 부정합 문제가 발생할 수 있다.

  * **REPETABLE READ**: 트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리 수준이다. MySQL의 디폴트 격리수준으로 Update 부정합(업데이트를 수행해야하는 컬럼을 잠글 수 없어 업데이트가 실행되지 않음), Phantom READ(데이터 조회 중 INSERT가 발생하여 없던 결과가 출력되는 현상)가 발생할 수 있다.

  * **SERIALIZABLE**: 가장 강력한 격리수준으로 읽기 작업에도 잠금을 발생시켜 다른 트랜잭션이 레코드를 변경할 수 없도록 한다. 동시처리 능력이 떨어지고 성능이 저하된다.

* **데이터베이스 파티셔닝**: DB에 저장되는 데이터 규모가 대용량화 되면서 기존에 사용하던 DB시스템의 용량의 한계와 성능저하를 가지고 오게 되어 TABLE을 파티션(Partion)이라는 작은 단위로 나누어 관리하는 기법, 가용성, 관리용이성, 성능 등 이점이 있지만 JOIN 비용이 늘어난다.

* **정규화**: 하나의 릴레이션에 여러 앤티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장공간이 낭비되고 갱신이상이 발생한다. 이를 해결하기 위해 거치는 과정 (삽입이상, 삭제이상, 갱신(수정)이상이 발생할 수 있다.) 

* **함수적 종속**: X와 Y를 임의의 애트리뷰트 집합이라고 할 때 X의 값이 Y의 값을 유일하게 결정한다면 “X는 Y를 함수적으로 결정한다” 고 한다.
정규화를 수행하였을 때 D는 무손실 조인과 함수적 종속을 보장하여야 한다.

* **클러스터**: 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이나 자주 사용하는 테이블의 데이터를 디스크의 같은 위치에 저장시키는 것, 데이터 조회 속도는 향상시키지만 저장, 수정, 삭제 또는 한 테이블 전체 Scan의 성능은 감소한다.
(주로 조회에 사용되고 컬럼안에 많은 중복데이터를 가지는 테이블,  join을 자주 하는 테이블에 클러스터링을 한다.)

* **클러스터 인덱스**: 물리적으로 행을 재배열, 넌 클러스터 인덱스보다 작은 사이즈, 30%이내에서 사용해야 좋다. 테이블당 1개를 갖으며 Primary Key 설정 시 해당 칼럼은 자동적으로 클러스터 인덱스 생성

* **논클러스터 인덱스**: 물리적으로 재배치하지 않음, 클러스터 인덱스 용량이 큼, 3% 이내에서 사용해야 좋은 선택도를 갖는다. 테이블당 249개를 갖으며 논클러스터 인덱스를 따로 명시해야 한다(인덱스 페이지를 따로 만듬)

* **CDC (Change Data Capture)**: 마지막으로 추출한 이후 변경된 데이터만 골라내는 기술, 데이터 백업이나 통합작업시 처리할 데이터가 방대할 경우 최근 변경된 데이터만 골라 옮기게 되면 생산성을 향상시킬 수 있다. 24시간 운영하는 시스템에서 사용시 다운타임 없이 실시간 백업/데이터 통합이 가능하다.

* **데이터 무결성**: 데이터의 정확성, 일관성, 유효성을 유지하는 것, RDBMS의 중요한 기능으로 주로 데이터에 적용하는 연산을 제한하여 무결성을 유지한다.

  * **개체 무결성(Entity integrity)**: 모든 테이블이 기본키로 선택된 필드를 가지고 있어야 한다. 기본키로 선택된 필드는 NULL을 허용하지 않는다.

  * **참조 무결성(Referential integrity)**: 참조관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것
  
* **기본키(Primary key)**: 테이블에서 특정 레코드를 구분하기 위하여 후보키 중 선택된 고유한 식별자, 유일성과 최소성을 만족하여야 하고 NULL값을 갖을 수 없다. 자주 변경되지 않는 값, 단순한 값을 선택하여야 한다.

* **슈퍼키(Super Key)**: 테이블에 존재하는 필드의 부분집합으로 유일성을 만족하여야 한다.

* **후보키(Candidate key)**: 기본키가 될 수 있는 키, 유일성과, 최소성을 모두 만족하여야 한다.

* **외래키(Foreign key)**: 한 테이블의 키 중 다른 테이블을 유일하게 식별할 수 있는 키, 중복된 값과 NULL을 갖을 수 있다. 참조되는 테이블에서 유일한 값을 참조해야 한다.  

* **RESTRICTED**: 레코드를 변경 또는 삭제하고자 할 때 해당 레코드를 참조하고 있는 개체가 있다면, 변경 또는 삭제 연산을 취소한다.

* **CASCADE**: 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체도 변경 또는 삭제된다. 
  
* **SET NULL**: 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체의 값을 NULL로 설정한다.    
<br>

# 용어정리 – JAVA

* **JVM** : 자바 가상 머신의 약자를 따서 줄여 부르는 용어로 JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다. 메모리 관리(GC)을 수행하며 스택기반의 가상머신. Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있다.
  * **Class Loader** : VM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
  * **Execution engine** : 바이트 코드를 실행시키는 역할
      * **Interpreter** : 바이트 코드를 한줄 씩 실행합니다.
      * **JIT 컴파일러** : 인터프리터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.
      * **GC(Garbage Collector)** : 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 수행
  * **Runtime Data Areas**: 프로그램 실행 중에 사용되는 다양한 영역
  * **JNI(Java Native Interface)**: 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공, Native 키워드를 사용하여 메서드를 호출 (대표적인 메서드는 Thread의 currentThread())
  * **Native Method Library**: C, C++로 작성된 라이브러리    
<br>     
* **Java의 실행방식**
  *  자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환
  *  Class Loader를 통해 class 파일들을 JVM으로 로딩.
  *  로딩된 class파일들은 Execution engine을 통해 해석
  *  해석된 바이트코드는 Runtime Data Areas 에 배치되어 수행
  
*  **GC(Garbage Collector)** : 힙 영역에서 사용하지 않는 객체들을 제거하는 작업. GC는 Minor GC, Major GC로 구분 되며, Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다. GC를 수행할 때는 GC를 수행하는 스레드 이외의 스레드는 모두 정지하며 이를 Stop-the-world라고 한다.
   *  **Minor GC** : Young 영역은 Eden / Survivor 이라는 두 영역으로 나뉨, Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사한다. 그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속 해서 살아남는 객체는 old 영역으로 이동하게 됩니다.
  
   *  **Major GC** : 위와 반대로 삭제되어야 하는 객체를 mark합니다. 그리고 지웁(sweep)니다. 메모리는 단편화 된 상태이므로 이를 한 군데에 모아주는 것을 Compaction이라 하며 compact라고 합니다. 그래서 Mark-Sweep-Compact 알고리즘이라고 합니다.
   <br>  

* **SOLID(객체지향 5대원칙)** 
  * **SRP(단일책임원칙)** 모든 클래스는 하나의 책임을 갖는다.
  * **OCP(개방-폐쇄 원칙)** 확장에는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다. 
  * **LSP(리스코프 치환 원칙)** 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  * **ISP(인터페이스 분리 원칙)** 큰 덩어리의 인터페이스를 구체적으로 작은 단위로 분리시켜, 꼭 필요한 메소드만 사용하게 한다.
  * **DIP(의존관계 역전 원칙)** 상위 모듈은 하위 모듈에 의존하지 않고, 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.