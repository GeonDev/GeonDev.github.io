---
layout: post
title: 백엔드 면접을 위한 IT 용어 정리
date: 2024-06-01
Author: Geon Son
categories: IT
tags: [OS, IT, Backend, Spring]
comments: true
toc: true
---


>[네트워크 & 운영체제 용어 참고](https://geondev.github.io/it-word-list-network/) 

이직을 준비하면서 이론을 너무 까먹어서 정리하려고 한다.

# 용어정리 – 데이터 베이스
* **OLTP(OnLine Transaction Processing)**: 네트워크상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 방식을 말한다. 주로 신용카드 조회 업무나 자동 현금 지급 등 금융 전산 관련 부문에서 많이 발생하기 때문에 ‘온라인 거래처리’라고도 한다. (효율적 처리 중심)

* **OLAP(OnLine Analytical Processing)**: 사용자가 다양한 각도에서 직접 대화식으로 정보를 분석하는 과정을 말한다. OLAP 시스템은 단독으로 존재하는 정보 시스템이 아니며, 데이터 웨어하우스나 데이터 마트와 같은 시스템과 상호 연관된다. (데이터 분석 중심)

* **트랜잭션 격리수준(Isolation Level)**: 동시에 여러 트랜잭션이 실행될 때, 트랜잭션 끼리 서로 얼마나 고립 되어 있는지를 확인하는 것, 특정 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 조회할 수 있는지 없는지 판단한다. 격리수준이 내려갈수록 성능이 좋아지지만 오류가 발생할 가능성이 커진다.

  * **READ UNCOMMITTED**: 어떤 트랙잭션의 변경내용이 COMMIT이나 ROLLBACK에 상관없이 모두 노출된다. 데이터의 정합성 문제로 RDBMS 표준에서는 인정하지 않는다.

  * **READ COMMITTED**: 어떤 트랜잭션의 변경내용이 COMMIT되어야만 다른 트랜잭션에서 조회할 수 있다. NON-REPETABLE READ 부정합 문제가 발생할 수 있다.

  * **REPETABLE READ**: 트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리 수준이다. MySQL의 디폴트 격리수준으로 Update 부정합(업데이트를 수행해야하는 컬럼을 잠글 수 없어 업데이트가 실행되지 않음), Phantom READ(데이터 조회 중 INSERT가 발생하여 없던 결과가 출력되는 현상)가 발생할 수 있다.

  * **SERIALIZABLE**: 가장 강력한 격리수준으로 읽기 작업에도 잠금을 발생시켜 다른 트랜잭션이 레코드를 변경할 수 없도록 한다. 동시처리 능력이 떨어지고 성능이 저하된다.

* **데이터베이스 파티셔닝**: DB에 저장되는 데이터 규모가 대용량화 되면서 기존에 사용하던 DB시스템의 용량의 한계와 성능저하를 가지고 오게 되어 TABLE을 파티션(Partion)이라는 작은 단위로 나누어 관리하는 기법, 가용성, 관리용이성, 성능 등 이점이 있지만 JOIN 비용이 늘어난다.

* **정규화**: 하나의 릴레이션에 여러 앤티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장공간이 낭비되고 갱신이상이 발생한다. 이를 해결하기 위해 거치는 과정 (삽입이상, 삭제이상, 갱신(수정)이상이 발생할 수 있다.) 

* **함수적 종속**: X와 Y를 임의의 애트리뷰트 집합이라고 할 때 X의 값이 Y의 값을 유일하게 결정한다면 “X는 Y를 함수적으로 결정한다” 고 한다.
정규화를 수행하였을 때 D는 무손실 조인과 함수적 종속을 보장하여야 한다.

* **클러스터**: 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이나 자주 사용하는 테이블의 데이터를 디스크의 같은 위치에 저장시키는 것, 데이터 조회 속도는 향상시키지만 저장, 수정, 삭제 또는 한 테이블 전체 Scan의 성능은 감소한다.
(주로 조회에 사용되고 컬럼안에 많은 중복데이터를 가지는 테이블,  join을 자주 하는 테이블에 클러스터링을 한다.)

* **클러스터 인덱스**: 물리적으로 행을 재배열, 넌 클러스터 인덱스보다 작은 사이즈, 30%이내에서 사용해야 좋다. 테이블당 1개를 갖으며 Primary Key 설정 시 해당 칼럼은 자동적으로 클러스터 인덱스 생성

* **논클러스터 인덱스**: 물리적으로 재배치하지 않음, 클러스터 인덱스 용량이 큼, 3% 이내에서 사용해야 좋은 선택도를 갖는다. 테이블당 249개를 갖으며 논클러스터 인덱스를 따로 명시해야 한다(인덱스 페이지를 따로 만듬)

* **CDC (Change Data Capture)**: 마지막으로 추출한 이후 변경된 데이터만 골라내는 기술, 데이터 백업이나 통합작업시 처리할 데이터가 방대할 경우 최근 변경된 데이터만 골라 옮기게 되면 생산성을 향상시킬 수 있다. 24시간 운영하는 시스템에서 사용시 다운타임 없이 실시간 백업/데이터 통합이 가능하다.

* **데이터 무결성**: 데이터의 정확성, 일관성, 유효성을 유지하는 것, RDBMS의 중요한 기능으로 주로 데이터에 적용하는 연산을 제한하여 무결성을 유지한다.

  * **개체 무결성(Entity integrity)**: 모든 테이블이 기본키로 선택된 필드를 가지고 있어야 한다. 기본키로 선택된 필드는 NULL을 허용하지 않는다.

  * **참조 무결성(Referential integrity)**: 참조관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것

* **슈퍼키(Super Key)**: 테이블에 존재하는 필드의 부분집합으로 유일성을 만족하여야 한다.

* **후보키(Candidate key)**: 기본키가 될 수 있는 키, 유일성과, 최소성을 모두 만족하여야 한다.

* **기본키(Primary key)**: 테이블에서 특정 레코드를 구분하기 위하여 후보키 중 선택된 고유한 식별자, 유일성과 최소성을 만족하여야 하고 NULL값을 갖을 수 없다. 자주 변경되지 않는 값, 단순한 값을 선택하여야 한다.

* **외래키(Foreign key)**: 한 테이블의 키 중 다른 테이블을 유일하게 식별할 수 있는 키, 중복된 값과 NULL을 갖을 수 있다. 참조되는 테이블에서 유일한 값을 참조해야 한다.  

* **RESTRICTED**: 레코드를 변경 또는 삭제하고자 할 때 해당 레코드를 참조하고 있는 개체가 있다면, 변경 또는 삭제 연산을 취소한다.
* **CASCADE**: 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체도 변경 또는 삭제된다.
* **SET NULL**: 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체의 값을 NULL로 설정한다.

# 용어정리 – JAVA

