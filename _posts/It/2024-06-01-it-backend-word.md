---
layout: post
title: 백엔드 이론을 위한 IT 용어 정리
date: 2024-06-01
Author: Geon Son
categories: IT
tags: [IT]
comments: true
toc: true
---

>[네트워크 & 운영체제 용어 참고](https://geondev.github.io/it-word-list-network/)  
>[참고](https://github.com/ksundong/backend-interview-question?tab=readme-ov-file)

업무만 하다보니 이론을 너무 까먹어서 정리하려고 한다.  <br>


# 용어정리 – 데이터 베이스
* **트랜잭션 격리수준(Isolation Level)**: 동시에 여러 트랜잭션이 실행될 때, 트랜잭션 끼리 서로 얼마나 고립 되어 있는지를 확인하는 것, 특정 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 조회할 수 있는지 없는지 판단한다. 격리수준이 내려갈수록 성능이 좋아지지만 오류가 발생할 가능성이 커진다.

  * **READ UNCOMMITTED**: 어떤 트랙잭션의 변경내용이 COMMIT이나 ROLLBACK에 상관없이 모두 노출된다. 데이터의 정합성 문제로 RDBMS 표준에서는 인정하지 않는다.

  * **READ COMMITTED**: 어떤 트랜잭션의 변경내용이 COMMIT되어야만 다른 트랜잭션에서 조회할 수 있다. NON-REPETABLE READ 부정합 문제가 발생할 수 있다.

  * **REPEATABLE READ**: 트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리 수준이다. MySQL의 디폴트 격리수준으로 Update 부정합(업데이트를 수행해야하는 컬럼을 잠글 수 없어 업데이트가 실행되지 않음), Phantom READ(데이터 조회 중 INSERT가 발생하여 없던 결과가 출력되는 현상)가 발생할 수 있다.

  * **SERIALIZABLE**: 가장 강력한 격리수준으로 읽기 작업에도 잠금을 발생시켜 다른 트랜잭션이 레코드를 변경할 수 없도록 한다. 동시처리 능력이 떨어지고 성능이 저하된다.
<br>
* **데이터베이스 파티셔닝**: DB에 저장되는 데이터 규모가 대용량화 되면서 기존에 사용하던 DB시스템의 용량의 한계와 성능저하를 가지고 오게 되어 TABLE을 파티션(Partion)이라는 작은 단위로 나누어 관리하는 기법, 가용성, 관리용이성, 성능 등 이점이 있지만 JOIN 비용이 늘어난다.
<br>
* **정규화**: 하나의 릴레이션에 여러 앤티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장공간이 낭비되고 갱신이상이 발생한다. 이를 해결하기 위해 거치는 과정 (삽입이상, 삭제이상, 갱신(수정)이상이 발생할 수 있다.) 
  * **함수적 종속**: X와 Y를 임의의 애트리뷰트 집합이라고 할 때 X의 값이 Y의 값을 유일하게 결정한다면 “X는 Y를 함수적으로 결정한다” 고 한다. 정규화를 수행하였을 때 D는 무손실 조인과 함수적 종속을 보장하여야 한다.
<br>
* **클러스터**: 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 조인이나 자주 사용하는 테이블의 데이터를 디스크의 같은 위치에 저장시키는 것, 데이터 조회 속도는 향상시키지만 저장, 수정, 삭제 또는 한 테이블 전체 Scan의 성능은 감소한다. (주로 조회에 사용되고 컬럼안에 많은 중복데이터를 가지는 테이블, join을 자주 하는 테이블에 클러스터링을 한다.)

  * **클러스터 인덱스**: 물리적으로 행을 재배열, 넌 클러스터 인덱스보다 작은 사이즈, 30%이내에서 사용해야 좋다. 테이블당 1개를 갖으며 Primary Key 설정 시 해당 칼럼은 자동적으로 클러스터 인덱스 생성

  * **논클러스터 인덱스**: 물리적으로 재배치하지 않음, 클러스터 인덱스 용량이 큼, 3% 이내에서 사용해야 좋은 선택도를 갖는다. 테이블당 249개를 갖으며 논클러스터 인덱스를 따로 명시해야 한다(인덱스 페이지를 따로 만듬)
<br>
* **데이터 무결성**: 데이터의 정확성, 일관성, 유효성을 유지하는 것, RDBMS의 중요한 기능으로 주로 데이터에 적용하는 연산을 제한하여 무결성을 유지한다.

  * **개체 무결성(Entity integrity)**: 모든 테이블이 기본키로 선택된 필드를 가지고 있어야 한다. 기본키로 선택된 필드는 NULL을 허용하지 않는다.

  * **참조 무결성(Referential integrity)**: 참조관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것
<br> 

* **기본키(Primary key)**: 테이블에서 특정 레코드를 구분하기 위하여 후보키 중 선택된 고유한 식별자, 유일성과 최소성을 만족하여야 하고 NULL값을 갖을 수 없다. 자주 변경되지 않는 값, 단순한 값을 선택하여야 한다.
* **슈퍼키(Super Key)**: 테이블에 존재하는 필드의 부분집합으로 유일성을 만족하여야 한다.
* **후보키(Candidate key)**: 기본키가 될 수 있는 키, 유일성과, 최소성을 모두 만족하여야 한다.
* **외래키(Foreign key)**: 한 테이블의 키 중 다른 테이블을 유일하게 식별할 수 있는 키, 중복된 값과 NULL을 갖을 수 있다. 참조되는 테이블에서 유일한 값을 참조해야 한다.  
<br>
* **RESTRICTED**: 레코드를 변경 또는 삭제하고자 할 때 해당 레코드를 참조하고 있는 개체가 있다면, 변경 또는 삭제 연산을 취소한다.
* **CASCADE**: 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체도 변경 또는 삭제된다. 

* **SET NULL**: 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체의 값을 NULL로 설정한다.    
<br>

# 용어정리 – JAVA

* **JVM** : 자바 가상 머신의 약자를 따서 줄여 부르는 용어로 JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행하는 것입니다. 메모리 관리(GC)을 수행하며 스택기반의 가상머신. Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있다.
  * **Class Loader** : VM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
  * **Execution engine** : 바이트 코드를 실행시키는 역할
      * **Interpreter** : 바이트 코드를 한줄 씩 실행합니다.
      * **JIT 컴파일러** : 인터프리터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.
      * **GC(Garbage Collector)** : 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 수행
  * **Runtime Data Areas**: 프로그램 실행 중에 사용되는 다양한 영역
  * **JNI(Java Native Interface)**: 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공, Native 키워드를 사용하여 메서드를 호출 (대표적인 메서드는 Thread의 currentThread())
  * **Native Method Library**: C, C++로 작성된 라이브러리    
<br>     
* **Java의 실행방식**
  *  자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환
  *  Class Loader를 통해 class 파일들을 JVM으로 로딩.
  *  로딩된 class파일들은 Execution engine을 통해 해석
  *  해석된 바이트코드는 Runtime Data Areas 에 배치되어 수행
<br>  

*  **GC(Garbage Collector)** : 힙 영역에서 사용하지 않는 객체들을 제거하는 작업. GC는 Minor GC, Major GC로 구분 되며, Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다. GC를 수행할 때는 GC를 수행하는 스레드 이외의 스레드는 모두 정지하며 이를 Stop-the-world라고 한다.
   *  **Minor GC** : Young 영역은 Eden / Survivor 이라는 두 영역으로 나뉨, Eden 영역에서 참조가 남아있는 객체를 mark하고 survivor 영역으로 복사한다. 그리고 Eden 영역을 비웁니다. Survivor 영역도 가득차면 같은 방식으로 다른 Survivor 영역에 복사하고 비웁니다. 이를 반복하다 보면 계속 해서 살아남는 객체는 old 영역으로 이동하게 됩니다.
  
   *  **Major GC** : 위와 반대로 삭제되어야 하는 객체를 mark합니다. 그리고 지웁(sweep)니다. 메모리는 단편화 된 상태이므로 이를 한 군데에 모아주는 것을 Compaction이라 하며 compact라고 합니다. 그래서 Mark-Sweep-Compact 알고리즘이라고 합니다.
   <br>  
* **SOLID(객체지향 5대원칙)** 
  * **SRP(단일책임원칙)** 모든 클래스는 하나의 책임을 갖는다.
  * **OCP(개방-폐쇄 원칙)** 확장에는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다. 
  * **LSP(리스코프 치환 원칙)** 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  * **ISP(인터페이스 분리 원칙)** 큰 덩어리의 인터페이스를 구체적으로 작은 단위로 분리시켜, 꼭 필요한 메소드만 사용하게 한다.
  * **DIP(의존관계 역전 원칙)** 상위 모듈은 하위 모듈에 의존하지 않고, 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.  
  <br>
* **JDK와 JRE** : JDK는 Java Development KIT의 약자로 개발하는데 사용되는 도구이며 JRE를 포함하고 있으며 JRE는 Java Runtime Environment의 약자로 자바로 만들어진 프로그램을 실행시키는데 필요한 도구가 들어있는 차이가 있다.
  <br>
* **Checked Exception과 Unchecked Exception** 
  * **Checked Exception** : RuntimeException을 상속하지 않고 반드시 에러 처리(try/catch or throw)를 해야한다. (대표적으로 FileNotFoundException)
  * **UncheckedException** : RuntimeException을 상속하면 UncheckedException. 체크 예외와는 달리 에러 처리를 강제하지 않음 (대표적으로 NullPointerException)
스프링 트랜잭션 추상화에서 rollback 대상은 UncheckedException
<br>
* **정적(static)** : static은 클래스 멤버라고 하며, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. static 키워드를 통해 생성된 정적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있다. 그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재하기 때문에 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있다.
<br>
* **오버라이딩과 오버로딩**
  * **오버라이딩(Overriding)** : 상위 클래스의 메소드를 재정의 하는 것을 의미.
  * **오버로딩(overloading)** : 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미
<br>
* **인터페이스와 추상클래스의 차이**
  * **추상클래스** : 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용. 단일 상속만 가능. 추상클래스를 상속하는 집합간에는 연관관계가 있다. 기능을 구체적으로 정의할수 있다.
  * **인터페이스** : 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용. 다중 상속 가능. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있다. 시그니처만 정의 가능
<br>
* **제네릭(Generics)** : 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법, 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여준다.
<br>

* **직렬화(Serialization)과 역직렬화(Deserialization)**
   * **직렬화(Serialization)** : 객체들의 데이터를 연속적인 데이터(스트림)로 변형하여 전송 가능한 형태로 만드는 것 (객체 데이터를 JSON으로 바꾼다.)
   * **역직렬화(Deserialization)** : 직렬화된 데이터를 다시 객체의 형태로 만드는 것 (JSON 데이터를 객체로 바꾼다)
<br>
* **JWT(Json Web Token)** : JWT란 Json 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰
JWT는 헤더, 페이로드, 시그니쳐로 구분됩니다. 헤더는 토큰의 타입, 암호화 알고리즘을 담고 있고, 페이로드는 토큰의 정보를 담는 부분이며, 시그니처는 토큰의 정보가 신뢰할 수 있는것인지 판단할 수 있도록 한다.
세션기반 인증은 서버에서 세션 정보를 관리해야하는 비용이 들고 분산환경에서도 관리하기 어렵지만 JWT는 그 자체로 정보를 가지고 있기 때문에 세션의 단점을 보완할 수 있다.


 # 용어정리 – SPRING

 * **Spring DI/IoC**
   * **IoC(제어의 역전)** : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크의 내부에서 결정된 대로 이루어진다.
   * **DI(의존관계 주입)** : Spring 프레임워크에서 지원하는 IoC의 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결하는 것, 
     * **생성자 주입** : 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용한다. 불변 보장, 컴파일중 오류 확인 가능, 순환 참조 에러 방지 등 이점이 있어 스프링에서 권장한다. 
     * **수정자(Setter) 주입** : 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록한다.
     * **필드 주입** : `@Autowired` 를 사용하는데 외부에서 변경이 불가능하여 테스트 하기 힘들다. DI 프레임워크 없이는 작동하기 힘들며, 주로 애플리케이션과 관계없는 테스트코드나 `@Configuration` 같은 스프링 설정 목적으로 사용
<br>
* **Spring Bean** : IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC컨테이너에서 가져와서 사용한다. `@Bean` 을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있다.

* **Spring Bean 생성과정** : 객체 생성 → 의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있습니다. Bean은 스프링 컨테이너에 의해 생명주기를 관리하며 빈 초기화방법은 `@PostConstruct` 를, 빈 소멸에서는 `@PreDestroy` 를 사용한다.
생성한 스프링 빈을 등록할 때는 ComponentScan을 이용하거나 `@Configuration` 의 `@Bean` 을 사용하여 빈 설정파일에 직접 빈을 등록할 수 있습니다.
<br>

* **Bean Scope** : 빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤(singleton), 프로토타입(prototype), request, session, application 등이 있다.
  * **singleton Scope** : 스프링 빈 스코프의 기본값, 스프링 컨테이너의 시작과 종료까지 유지, 싱글톤 스코프의 빈을 조회하면, 스프링 컨테이너는 항상 같은 인스턴스를 반환한다.
  * **prototype Scope** : 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프, 항상 새로운 인스턴스를 생성해서 반환한다  
<br>

* **Bean/Component 차이점**
  * **@Bean** : 개발자가 작성한 method를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회(싱글톤) 생성
  * **@Component** : 개발자가 작성한 class를 기반으로 실행시점에 인스턴스 객체를 1회(싱글톤) 생성 (`@Controller`, `@Service`, `@Repository` 는 모두 `@Component` 이다)


* **Servlet Filter** : 서블릿 실행 전, 후에 어떤 작업을 하고자 할때 사용한다. 이 필터가 있음으로써 WAS에서 설정을 변경하지 않고도 모든 서블릿에 영향을 준다.
  * **Filter 에러 처리** : Filter는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생했을 때 ErrorController에서 처리

* **Spring Interceptor** : Spring에서 Handler를 실행하기 전후나, ViewResolver를 통해 컨트롤러에서 리턴한 View Name으로부터 렌더링을 담당할 View 오브젝트를 준비해 돌려준 후 실제 View를 렌더링한 후에 어떠한 처리를 담당.
   * **Interceptor 에러 처리** : Interceptor는 DispatcherServlet 내부에 존재하기 때문에 `@ControllerAdvice`를 적용해서 처리.

 # 용어정리 – JPA
 * **영속성 컨텍스트** : 엔티티를 영구 저장하는 환경. 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다. 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
* **영속성 컨텍스트의 이점** 
  * **1차 캐시** : 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓는다.
  * **동일성 보장** : 엔티티의 동일성을 보장, 동일성 비교(==)가 가능합니다.
  * **쓰기 지연** : 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있다.
  * **변경 감지** : commit 되는 시점에 Entity와 스냅샷과 비교하여 update SQL을 생성합니다.
  * **지연로딩** : 엔티티에서 해당 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다.
<br>
* **프록시(JPA)** : 엔티티를 조회할 때 연관관계를 맺고 있는 다른 엔티티도 같이 조회 해야 하지만 연관된 엔티티가 항상 필요하지 않은데 DB를 조회하면 불필요한 데이터 조회가 발생하게 되기 때문에, 실제 사용될 때까지 DB 조회를 지연시킬 수 있도록 실제 엔티티 대신할 가짜 객체가 필요한데 이를 프록시 객체라고 한다.
<br>

* **N + 1 문제** : 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 되는것, 조회 시 1개의 쿼리를 생각하고 설계를 했으나 나오지 않아도 되는 조회의 쿼리가 N개가 더 발생하는 문제
  * **즉시 로딩에서 발생** :  JPQL을 사용하는 경우 전체 조회를 했을 때, 영속성 컨텍스트가 아닌 데이터베이스에서 직접 데이터를 조회한 다음 즉시로딩 전략이 동작하기 때문.
  * **지연 로딩에서 발생** : 지연로딩 전략을 사용한 하위 엔티티를 로드할 때, JPA에서 프록시 엔티티를 unproxy 할 때 해당 엔티티를 조회하기 위한 추가적인 쿼리가 실행되어 발생.

* **N + 1 해결**
  * **패치 조인(Fetch Join)** : 미리 두 테이블을 JOIN 하여 한 번에 모든 데이터를 가져올 수 있다면 애초에 N+1 문제가 발생하지 않음. 1:N 관계가 두 개 이상인 경우 사용 불가, 카테시안 곱(Cartesian Product)이 발생 하여 중복이 생길 수 있다
  * **배치 사이즈(Batch Size)** : @BatchSize 어노테이션을 사용하거나 default_batch_fetch_size 설정을 추가하여 한 번의 쿼리로 여러 개의 연관된 엔티티를 조회하는 방법, 엔티티를 지정한 개수 만큼 IN을 활용하여 호출하게 된다.

